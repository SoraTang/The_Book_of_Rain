<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>雨之书：第三章 - 机制A+B（霁·终章）</title>
    <style>
        /* * 基础样式设置 
         * 目标：明亮、朦胧、雨后清晨的空气感
         */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #e6e9f0; /* 兜底色 */
            cursor: none; /* 隐藏默认光标 */
            font-family: 'Georgia', 'Times New Roman', serif;
        }

        /* 自定义圈状光标 */
        .cursor-ring {
            position: fixed;
            top: -100px; /* 初始隐藏 */
            left: -100px;
            width: 24px;
            height: 24px;
            border: 1.5px solid rgba(80, 90, 100, 0.6); /* 深灰蓝圈 */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 9999;
            transition: transform 0.1s ease-out;
        }

        /* 标题容器：绝对居中 */
        .title-container {
            position: absolute;
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1; 
            pointer-events: none; 
            width: 100%;
            /* 稍微调整层级，确保不遮挡气泡交互 */
        }

        /* 主标题：霁 - 巨型化 */
        .main-title {
            font-size: 18rem; /* 增大 2 倍 */
            font-weight: normal;
            margin: 0;
            line-height: 0.9; /* 稍微紧凑一点 */
            letter-spacing: 0;
            /* 维持清透质感 */
            color: rgba(80, 95, 110, 0.2); 
            mix-blend-mode: multiply; 
            display: block;
        }

        /* 英文装饰：PETRICHOR - 全大写、分开 */
        .sub-title-en {
            display: block; 
            font-size: 3.5rem; /* 放大 */
            text-transform: uppercase; /* 全大写 */
            margin-top: 1.2rem; /* 与中文隔开 */
            letter-spacing: 0.2em; /* 宽间距 */
            font-weight: 300;
            color: rgba(80, 95, 110, 0.3); 
            mix-blend-mode: multiply;
        }

        /* 触发式副标题 - 独立定位到中下方 */
        .intro-text {
            position: absolute;
            bottom: 18%; /* 屏幕中下方 */
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 2rem;
            letter-spacing: 0.1em;
            color: rgba(90, 100, 110, 0.8);
            opacity: 0; /* 初始隐藏 */
            transform: translateY(20px);
            transition: opacity 2.5s ease, transform 2.5s ease; /* 更慢的浮现 */
            z-index: 1;
            pointer-events: none;
        }

        /* 背景层：材质感背景 */
        .fog-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* 顶部深蓝，底部湿润白雾 */
            background: linear-gradient(to bottom, #b0c0d0 0%, #e6eef5 60%, #ffffff 100%);
            z-index: 0;
        }
        
        /* 纹理层：细腻度 */
        .texture-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.4;
            pointer-events: none;
            background-image: repeating-linear-gradient(
                45deg,
                rgba(100, 110, 120, 0.03) 0px,
                rgba(100, 110, 120, 0.03) 1px,
                transparent 1px,
                transparent 3px
            );
        }

        /* 噪点层 */
        .noise-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.08;
            z-index: 2;
            pointer-events: none;
            mix-blend-mode: multiply;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        /* 交互画布 */
        canvas {
            display: block;
            position: relative;
            z-index: 3;
        }

        /* 隐藏字体加载 */
        .font-loader {
            font-family: 'Georgia', 'Times New Roman', serif;
            position: absolute;
            visibility: hidden;
            color: #555;
        }
    </style>
</head>
<body>

    <div class="cursor-ring"></div>
    
    <!-- 标题层 -->
    <div class="title-container">
        <div class="main-title">霁</div>
        <div class="sub-title-en">PETRICHOR</div>
    </div>

    <!-- 叙事层 (独立) -->
    <div class="intro-text" id="introText">After the storm, a new order takes hold</div>

    <div class="fog-layer"></div>
    <div class="texture-layer"></div>
    <div class="noise-layer"></div>
    <canvas id="canvas"></canvas>
    <div class="font-loader">fragments</div>

<script>
/**
 * 核心逻辑实现 - 版本 25.0 (限制最大生长长度)
 * 修改：
 * 1. Root.feed(): 增加判断，如果已超出屏幕范围则不增加长度，且 maxLength 设有硬上限。
 * 2. Root.update(): 强化边界检测，超出屏幕底部一定距离强制停止生长。
 */

// --- 词库定义 ---
const WORD_POOLS = [
    { weight: 5, words: ["rai—", "—ain", "dr—p", "drip—", "—mist", "va—or", "—apor", "cl—ud", "hu—id", "—et", "cond—", "—ense", "flo—", "—ood", "we—", "—etness"] },
    { weight: 3, words: ["ord—", "—order", "sys—", "—stem", "fra—", "—cture", "spl—", "—plit", "br—ak", "—oken", "pa—", "—ttern", "frag—", "—ment", "dis—", "—rupt", "re—", "—write", "un—", "—ravel"] },
    { weight: 3, words: ["be—", "—fore", "af—", "—ter", "sti—", "—ll", "ye—", "—t", "mo—", "—ment", "pa—", "—ssing", "re—", "—main", "no—", "—longer"] },
    { weight: 2, words: ["gli—", "—itch", "er—", "—ror", "fa—", "—iled", "lo—", "—st", "no—", "—ise", "si—", "—nal", "co—", "—rupt", "mis—", "—read", "ov—", "—flow"] },
    { weight: 1, words: ["ten—", "—sion", "an—", "—xious", "cal—", "—m", "hea—", "—vy", "ho—", "—llow", "dre—", "—ary", "si—", "—lent", "we—", "—ary", "un—", "—sure"] },
    { weight: 0.5, words: ["ne—", "—order", "re—", "—align", "str—", "—ucture", "co—", "—here", "pa—", "—ce", "for—", "—m"] }
];

const WEIGHTED_TEXT_LIST = [];
WORD_POOLS.forEach(pool => {
    const count = Math.ceil(pool.weight * 2); 
    for(let i=0; i<count; i++) {
        WEIGHTED_TEXT_LIST.push(...pool.words);
    }
});

const CONFIG = {
    particleCount: 12,        
    spawnRate: 0.015,
    speedMin: 0.3,            
    speedMax: 0.8,
    
    // 植物系统配置
    maxRoots: 60,             
    rootHitRange: 60,         
    
    colors: {
        glowBase: 'rgba(255, 255, 255, 0.8)', 
        glowShadow: 'rgba(200, 230, 255, 0.6)',
        text: 'rgba(50, 60, 70, ', 
        dust: 'rgba(120, 130, 140, ',
        shard: 'rgba(90, 100, 110, ',
        flash: 'rgba(255, 255, 255, 0.95)',
        ripple: 'rgba(255, 255, 255, 0.3)',
        flowerWithered: 'rgba(100, 80, 60, ', 
        // Leaf colors are now dynamic per root
    }
};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const cursorRing = document.querySelector('.cursor-ring');
const introText = document.getElementById('introText');

let width, height;
let particles = [];
let fragments = [];
let roots = [];        
let ripples = [];      
let flowers = [];      
let mouse = { x: -9999, y: -9999 };
let firstContactMade = false; 

function init() {
    resize();
    window.addEventListener('resize', resize);
    window.addEventListener('mousemove', (e) => { 
        mouse.x = e.clientX; 
        mouse.y = e.clientY; 
        if (cursorRing) {
            cursorRing.style.left = e.clientX + 'px';
            cursorRing.style.top = e.clientY + 'px';
        }
    });
    window.addEventListener('touchmove', (e) => {
        const touch = e.touches[0];
        mouse.x = touch.clientX; 
        mouse.y = touch.clientY;
        if (cursorRing) {
            cursorRing.style.left = touch.clientX + 'px';
            cursorRing.style.top = touch.clientY + 'px';
        }
    }, { passive: false });
    window.addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        mouse.x = touch.clientX; 
        mouse.y = touch.clientY;
        if (cursorRing) {
            cursorRing.style.left = touch.clientX + 'px';
            cursorRing.style.top = touch.clientY + 'px';
        }
    }, { passive: false });
}

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    const dpr = window.devicePixelRatio || 1;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(dpr, dpr);
}

function randomRange(min, max) {
    return Math.random() * (max - min) + min;
}

// ---------------------------------------------------------
// 类：花朵 (Flower)
// ---------------------------------------------------------
class Flower {
    constructor(x, y, parentRoot) {
        this.x = x;
        this.y = y;
        this.parentRoot = parentRoot; 
        this.size = 0;
        this.maxSize = randomRange(8, 12); 
        this.state = 'growing'; 
        this.opacity = 0;
        
        const rand = Math.random();
        if (rand < 0.33) {
            this.color = 'rgba(255, 200, 50, '; 
        } else if (rand < 0.66) {
            this.color = 'rgba(255, 100, 100, '; 
        } else {
            this.color = 'rgba(255, 250, 240, '; 
        }

        this.rot = randomRange(0, Math.PI * 2);
        this.rotSpeed = randomRange(-0.02, 0.02);
        
        this.vx = 0;
        this.vy = 0;
    }

    update() {
        if (this.parentRoot && this.parentRoot.life < 0.3 && this.state !== 'falling') {
            this.state = 'withering';
        }
        if (this.parentRoot && this.parentRoot.life <= 0 && this.state !== 'falling') {
            this.state = 'falling';
        }

        if (this.state === 'growing') {
            this.size += 0.15; 
            this.opacity += 0.05;
            if (this.size >= this.maxSize) {
                this.state = 'blooming';
                this.opacity = 1.0;
            }
        } else if (this.state === 'blooming') {
            this.currentSize = this.size;
        } else if (this.state === 'withering') {
            this.size *= 0.99;
            this.opacity -= 0.005;
        } else if (this.state === 'falling') {
            this.vy += 0.05; 
            this.x += Math.sin(Date.now() * 0.01) * 0.5; 
            this.y += this.vy;
            this.rot += this.rotSpeed;
            this.opacity -= 0.01;
        }
    }

    draw() {
        if (this.opacity <= 0) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        
        let fillColor;
        if (this.state === 'falling' || this.state === 'withering') {
            ctx.rotate(this.rot);
            fillColor = CONFIG.colors.flowerWithered + this.opacity + ')';
        } else {
            fillColor = this.color + this.opacity + ')';
        }
        
        ctx.fillStyle = fillColor;

        const s = (this.state === 'blooming') ? this.currentSize : this.size;
        
        ctx.beginPath();
        for(let i=0; i<6; i++) { 
            ctx.rotate(Math.PI * 2 / 6);
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(s * 0.6, s * 0.9, 0, s * 1.4); 
            ctx.quadraticCurveTo(-s * 0.6, s * 0.9, 0, 0);
        }
        ctx.fill();
        
        if (this.state !== 'falling') {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.25, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.restore();
    }
}

// ---------------------------------------------------------
// 类：顶部吸收涟漪
// ---------------------------------------------------------
class TopRipple {
    constructor(x) {
        this.x = x;
        this.y = 0; 
        this.rx = 10; 
        this.ry = 2;  
        this.opacity = 1.0;
        this.growth = 2.0;
    }
    
    update() {
        this.rx += this.growth; 
        this.ry += this.growth * 0.2; 
        this.opacity -= 0.02; 
    }
    
    draw() {
        if (this.opacity <= 0) return;
        ctx.strokeStyle = CONFIG.colors.ripple;
        ctx.globalAlpha = this.opacity;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.ellipse(this.x, this.y, this.rx, this.ry, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }
}

// ---------------------------------------------------------
// 类：叶片 (Leaf)
// ---------------------------------------------------------
class Leaf {
    constructor(x, y, angle, size) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.targetSize = size;
        this.currentSize = 0;
    }

    update() {
        if (this.currentSize < this.targetSize) {
            this.currentSize += 0.15;
        }
    }

    draw(ctx, leafColor, opacity, isWithering, witheredColor) {
        if (opacity <= 0) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        if (isWithering) {
             ctx.fillStyle = witheredColor + (opacity * 0.6) + ')';
        } else {
             ctx.fillStyle = leafColor + (opacity * 0.6) + ')';
        }
        
        const s = this.currentSize;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        // 上半边
        ctx.bezierCurveTo(s * 0.3, -s * 0.3, s * 0.7, -s * 0.3, s, 0);
        // 下半边
        ctx.bezierCurveTo(s * 0.7, s * 0.3, s * 0.3, s * 0.3, 0, 0);
        ctx.fill();
        
        ctx.restore();
    }
}

// ---------------------------------------------------------
// 类：植物 (Root/Vine)
// ---------------------------------------------------------
class Root {
    constructor(x, generation = 0, initialLengthLimit = 0, parentColorStr = null, parentLeafColor = null, parentWitheredColor = null) {
        this.x = x;
        this.y = 0;
        this.generation = generation; 
        
        this.points = [{x: x, y: 0}];
        this.leaves = []; 
        
        this.angle = Math.PI / 2;
        this.noiseOffset = Math.random() * 1000; 
        
        if (generation === 0) {
            // 初始生长长度 (屏幕高度的 30% - 70%)
            const randomGrowth = randomRange(0.3, 0.7);
            this.maxLength = initialLengthLimit > 0 ? initialLengthLimit : height * randomGrowth;
        } else {
            this.maxLength = 50 + Math.random() * 80; 
        }
        
        this.currentLength = 0;
        this.growthRate = 1.2 + Math.random() * 0.8; 
        
        this.baseWidth = randomRange(4.5, 8.0); 
        
        this.growing = true;
        this.life = 1.0; 
        // 存活时间
        this.maxLife = randomRange(6000, 10000); 
        this.age = 0;
        
        // --- 颜色随机逻辑 (每个植物独特) ---
        if (parentColorStr) {
            this.colorStr = parentColorStr;
            this.leafColorStr = parentLeafColor;
            this.witheredColorStr = parentWitheredColor;
        } else {
            const h = 130 + Math.random() * 80;
            const s = 20 + Math.random() * 40; 
            const l = 30 + Math.random() * 30; 
            this.colorStr = `hsla(${h}, ${s}%, ${l}%, `;
            
            const lh = h + (Math.random() - 0.5) * 30;
            const ls = s + 10;
            const ll = l + 5;
            this.leafColorStr = `hsla(${lh}, ${ls}%, ${ll}%, `;
            
            this.witheredColorStr = `hsla(${30 + Math.random() * 20}, 40%, 25%, `;
        }
        
        this.leafCounter = 0;
        this.nextLeafSide = (Math.random() < 0.5) ? 1 : -1;
    }
    
    feed() {
        if (this.generation === 0) {
            // 如果已经超出屏幕范围，停止喂养，防止无限生长
            const lastY = this.points[this.points.length - 1].y;
            if (lastY > height + 50) {
                this.growing = false;
                return;
            }

            const randomAdd = randomRange(0.3, 0.7);
            this.maxLength += height * randomAdd;
            
            // 设置硬上限：不超过屏幕高度的 1.3 倍
            if (this.maxLength > height * 1.3) {
                this.maxLength = height * 1.3;
            }

            this.growing = true;
            this.life = 1.0; 
            this.age = 0;    
        }
    }

    update() {
        if (this.growing) {
            // 强化边界保护：如果当前点已经超出屏幕底部一定距离，强制停止生长
            if (this.points[this.points.length-1].y > height + 50) {
                this.growing = false;
            }

            if (this.currentLength < this.maxLength && this.growing) {
                const lastP = this.points[this.points.length - 1];
                
                this.noiseOffset += 0.05;
                const noise = Math.sin(this.noiseOffset) * 0.5 + Math.cos(this.noiseOffset * 0.3) * 0.3;
                
                const targetAngle = Math.PI / 2 + noise * 0.6;
                this.angle += (targetAngle - this.angle) * 0.05;

                const nx = lastP.x + Math.cos(this.angle) * this.growthRate;
                const ny = lastP.y + Math.sin(this.angle) * this.growthRate;
                
                this.points.push({x: nx, y: ny});
                this.currentLength += this.growthRate;
                
                // --- 叶片生成 ---
                this.leafCounter++;
                if (this.leafCounter > 15) { 
                    this.leafCounter = 0;
                    if (Math.random() < 0.8) { 
                        // 叶片尺寸
                        const leafSize = randomRange(30, 55);
                        
                        const offset = 1.0 * this.nextLeafSide;
                        const leafAngle = this.angle + offset;
                        
                        this.leaves.push(new Leaf(nx, ny, leafAngle, leafSize));
                        this.nextLeafSide *= -1;
                    }
                }
                
                // --- 无分叉 ---

                // --- 开花逻辑 ---
                if (ny > height * 0.4 && Math.random() < 0.005) {
                     flowers.push(new Flower(nx, ny, this));
                }

            } else {
                this.growing = false;
            }
        }
        
        for(let leaf of this.leaves) {
            leaf.update();
        }
        
        if (!this.growing) {
            this.age++;
            if (this.age > this.maxLife) {
                this.life -= 0.0015; 
            }
        }
    }
    
    draw() {
        if (this.life <= 0) return;
        
        const isWithering = (this.age > this.maxLife);
        
        for(let leaf of this.leaves) {
            leaf.draw(ctx, this.leafColorStr, this.life, isWithering, this.witheredColorStr);
        }

        ctx.beginPath();
        
        if (isWithering) {
            ctx.strokeStyle = this.witheredColorStr + (0.7 * this.life) + ')';
        } else {
            ctx.strokeStyle = this.colorStr + (0.7 * this.life) + ')'; 
        }

        ctx.lineWidth = Math.max(1.0, this.baseWidth - this.generation); 
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round'; 
        
        if (this.points.length > 1) {
            ctx.moveTo(this.points[0].x, this.points[0].y);
            for (let i = 1; i < this.points.length; i++) {
                ctx.lineTo(this.points[i].x, this.points[i].y);
            }
        }
        ctx.stroke();
    }
}

// ---------------------------------------------------------
// 类：残片 (Fragment)
// ---------------------------------------------------------
class Fragment {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        
        const angle = Math.random() * Math.PI * 2;
        const forceMultiplier = (type === 'shard' || type === 'line') ? 3.0 : 2.0; 
        const force = 0.5 + Math.random() * forceMultiplier;
        
        this.vx = Math.cos(angle) * force;
        this.vy = Math.sin(angle) * force;
        
        this.opacity = 1.0;
        this.decay = 0.005 + Math.random() * 0.01; 
        
        if (this.type === 'text') {
            this.content = WEIGHTED_TEXT_LIST[Math.floor(Math.random() * WEIGHTED_TEXT_LIST.length)];
            this.size = 14 + Math.random() * 10;
            this.rotation = (Math.random() - 0.5) * 0.5;
        } else if (this.type === 'line') {
            this.length = 5 + Math.random() * 10;
            this.angle = Math.random() * Math.PI * 2;
            this.rotSpeed = (Math.random() - 0.5) * 0.2;
        } else if (this.type === 'shard') {
            this.size = 3 + Math.random() * 4;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotSpeed = (Math.random() - 0.5) * 0.1;
        } else {
            this.size = 1 + Math.random() * 2;
        }
    }

    update() {
        this.vx *= 0.96; 
        this.vy *= 0.96;
        this.vy += 0.03; 
        
        this.x += this.vx;
        this.y += this.vy;
        
        if (this.type === 'line') this.angle += this.rotSpeed;
        if (this.type === 'shard') this.rotation += this.rotSpeed;
        
        if (this.type === 'text') {
             this.x += Math.sin(Date.now() * 0.002 + this.y * 0.1) * 0.1;
        }
        
        this.opacity -= this.decay;
    }

    draw() {
        if (this.opacity <= 0) return;
        
        if (this.type === 'text') {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.fillStyle = CONFIG.colors.text + this.opacity + ')';
            ctx.font = `italic ${this.size}px Georgia, "Times New Roman", serif`;
            ctx.textAlign = "center";
            ctx.fillText(this.content, 0, 0);
            ctx.restore();
        } else if (this.type === 'line') {
            ctx.strokeStyle = CONFIG.colors.shard + this.opacity + ')';
            ctx.lineWidth = 1;
            ctx.beginPath();
            const lx = Math.cos(this.angle) * this.length;
            const ly = Math.sin(this.angle) * this.length;
            ctx.moveTo(this.x - lx/2, this.y - ly/2);
            ctx.lineTo(this.x + lx/2, this.y + ly/2);
            ctx.stroke();
        } else if (this.type === 'shard') {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.fillStyle = CONFIG.colors.shard + this.opacity + ')';
            ctx.beginPath();
            ctx.moveTo(0, -this.size);
            ctx.lineTo(this.size, this.size);
            ctx.lineTo(-this.size, this.size);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        } else { 
            ctx.fillStyle = CONFIG.colors.dust + this.opacity + ')';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

// ---------------------------------------------------------
// 类：光团 (LightParticle)
// ---------------------------------------------------------
class LightParticle {
    constructor() {
        this.reset(true);
    }

    reset(init = false) {
        this.x = Math.random() * width;
        this.y = height + 60 + Math.random() * 100;
        
        this.size = 25 + Math.random() * 35; 
        this.speed = CONFIG.speedMin + Math.random() * (CONFIG.speedMax - CONFIG.speedMin);
        
        this.pulseOffset = Math.random() * 100;
        this.state = 'rising'; // rising, bursting, dead
        this.opacity = 0;
        
        const typeRand = Math.random();
        if (typeRand < 0.5) this.burstType = 'diffuse';
        else if (typeRand < 0.8) this.burstType = 'ripple';
        else this.burstType = 'sharp';

        this.burstScale = 1.0; 
        this.burstOpacity = 1.0;
    }

    update() {
        if (this.state === 'rising') {
            this.y -= this.speed;
            
            const t = Date.now() * 0.0005;
            this.x += Math.sin(t + this.pulseOffset) * 0.3;
            
            const pulseAmp = this.burstType === 'sharp' ? 5 : 3;
            this.currentSize = this.size + Math.sin(Date.now() * 0.002 + this.pulseOffset) * pulseAmp;

            if (this.opacity < 1) this.opacity += 0.01;

            // 1. 触碰检测
            const dx = this.x - mouse.x;
            const dy = this.y - mouse.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < this.currentSize + 25) {
                this.triggerBurst();
            }

            // 2. 触顶检测 (机制 B)
            if (this.y < 20) {
                this.triggerAbsorption();
            }

        } else if (this.state === 'bursting') {
            if (this.burstType === 'sharp') {
                this.burstScale += 0.3; 
                this.burstOpacity -= 0.1;
            } else if (this.burstType === 'ripple') {
                this.burstScale += 0.1; 
                this.burstOpacity -= 0.05;
            } else {
                this.burstScale += 0.15;
                this.burstOpacity -= 0.08;
            }
            
            if (this.burstOpacity <= 0) {
                this.spawnFragments();
                this.state = 'dead';
            }
        }
    }

    triggerBurst() {
        this.state = 'bursting';
    }

    // 修改：群发逻辑 + 触发叙事
    triggerAbsorption() {
        this.state = 'dead'; 
        ripples.push(new TopRipple(this.x));
        
        // 触发叙事字幕
        if (!firstContactMade) {
            firstContactMade = true;
            if(introText) {
                introText.style.opacity = '1';
                introText.style.transform = 'translateY(0)';
                
                // New logic: fade out after 5s
                setTimeout(() => {
                    introText.style.opacity = '0';
                }, 10000);
            }
        }
        
        let fedCount = 0;
        const feedLimit = Math.floor(randomRange(3, 6)); 
        
        for (let r of roots) {
            if (r.generation === 0 && Math.abs(r.x - this.x) < CONFIG.rootHitRange) {
                r.feed();
                fedCount++;
                if (fedCount >= feedLimit) break;
            }
        }
        
        if (fedCount === 0) {
            const mainRootCount = roots.filter(r => r.generation === 0).length;
            if (mainRootCount < CONFIG.maxRoots) {
                const spawnCount = Math.floor(randomRange(1, 4));
                for(let i=0; i<spawnCount; i++) {
                    roots.push(new Root(this.x + randomRange(-20, 20), 0));
                }
            }
        }
    }

    spawnFragments() {
        const textCount = 2 + Math.floor(Math.random() * 2); 
        const otherCount = 2 + Math.floor(Math.random() * 3);

        for (let i = 0; i < textCount; i++) {
            const r = Math.random() * this.size * 0.6; 
            const a = Math.random() * Math.PI * 2;
            fragments.push(new Fragment(
                this.x + Math.cos(a) * r, 
                this.y + Math.sin(a) * r,
                'text'
            ));
        }

        for (let i = 0; i < otherCount; i++) {
            const r = Math.random() * this.size * 0.8;
            const a = Math.random() * Math.PI * 2;
            
            let type = 'dust';
            if (this.burstType === 'sharp') type = 'shard'; 
            if (this.burstType === 'ripple') type = 'line'; 
            
            fragments.push(new Fragment(
                this.x + Math.cos(a) * r, 
                this.y + Math.sin(a) * r,
                type
            ));
        }
    }

    draw() {
        if (this.state === 'dead') return;

        if (this.state === 'rising') {
            ctx.globalAlpha = this.opacity * 0.7;
            
            ctx.shadowBlur = 25;
            ctx.shadowColor = CONFIG.colors.glowShadow;
            ctx.fillStyle = CONFIG.colors.glowBase;
            
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.currentSize * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
            ctx.fill();
            
            if (this.burstType === 'sharp') {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

        } else if (this.state === 'bursting') {
            ctx.globalAlpha = this.burstOpacity;
            ctx.fillStyle = CONFIG.colors.flash;
            
            if (this.burstType === 'diffuse') {
                ctx.shadowBlur = 40;
                ctx.shadowColor = 'white';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.burstScale, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            } 
            else if (this.burstType === 'ripple') {
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'white';
                ctx.strokeStyle = CONFIG.colors.flash;
                ctx.lineWidth = 4 * this.burstOpacity;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.burstScale, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            else if (this.burstType === 'sharp') {
                ctx.shadowBlur = 30;
                ctx.shadowColor = 'white';
                const s = this.size * this.burstScale;
                ctx.beginPath();
                ctx.moveTo(this.x - s * 1.5, this.y);
                ctx.lineTo(this.x + s * 1.5, this.y);
                ctx.moveTo(this.x, this.y - s * 1.5);
                ctx.lineTo(this.x, this.y + s * 1.5);
                ctx.lineWidth = 3;
                ctx.strokeStyle = CONFIG.colors.flash;
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(this.x, this.y, s * 0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        ctx.globalAlpha = 1.0;
    }
}

// ---------------------------------------------------------
// 主循环
// ---------------------------------------------------------
function loop() {
    ctx.clearRect(0, 0, width, height);

    if (particles.length < CONFIG.particleCount && Math.random() < CONFIG.spawnRate) {
        particles.push(new LightParticle());
    }

    // 植物
    for (let i = roots.length - 1; i >= 0; i--) {
        const r = roots[i];
        r.update();
        r.draw();
        // 彻底死亡才移除
        if (r.life <= 0) {
            roots.splice(i, 1);
        }
    }

    // 花朵
    for (let i = flowers.length - 1; i >= 0; i--) {
        const f = flowers[i];
        f.update();
        f.draw();
        // 掉出屏幕或消失
        if (f.opacity <= 0 || f.y > height + 20) {
            flowers.splice(i, 1);
        }
    }
    
    // 涟漪
    for (let i = ripples.length - 1; i >= 0; i--) {
        const r = ripples[i];
        r.update();
        r.draw();
        if (r.opacity <= 0) {
            ripples.splice(i, 1);
        }
    }

    // 气泡
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update();
        p.draw();
        if (p.state === 'dead') {
            particles.splice(i, 1);
        }
    }

    // 残片
    for (let i = fragments.length - 1; i >= 0; i--) {
        const f = fragments[i];
        f.update();
        f.draw();
        if (f.opacity <= 0) {
            fragments.splice(i, 1);
        }
    }

    requestAnimationFrame(loop);
}

init();
loop();

</script>
</body>
</html>